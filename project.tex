\section{Wireless Networked Embedded Systems Developed (selected)}
\subsection{PRK-based Scheduling Protocol (PRKS)}
\cvitem{}{
PRKS guarantees the reliability of a wireless link is no less than requirement in the presence of interference while maximizing throughput. This is done by identifying the optimal parameter K in the PRK interference model, which in turn is formulated as a distributed control problem. \textbf{Numerous underpinnings of TinyOS, such as execution model and resource sharing mechanism, intend to shield programmers from many complexities of programming a concurrent system, which comes at the expense of nondeterministic execution. To cater to PRKS's needs of predictable timing, I tailor these fundamental underlying services.} More specifically, there are five primary challenges in the implementation: (1) the controller is distributed, and nodes can have inconsistent view of plant states due to diffusion delay; (2) the protocol is based on TDMA and requires global time synchronization, but the de facto time synchronization protocol FTSP for TelosB is buggy and yields intolerable synchronization errors; (3) most protocol codes run in asynchronous mode, causing concurrency issues; (4) TinyOS's task execution model makes execution delay very nondeterministic; (5) many computations are intensive and experience highly varying delays. \textbf{I single-handedly tackled these challenges as well as other challenges posed by extreme memory constraints of TelosB motes using TinyOS. In addition to PRKS, I also implemented 4 other protocols and 2 PRKS variants for comparison from the ground up.} %:} 
%\begin{itemize}
%\item \emph{RTS-CTS}: a contention-based MAC protocol that uses CSMA/CA and RTS-CTS to ameliorate the impact of co-channel interference and hidden terminals;
%\item \emph{RIDB}: a TDMA scheduling protocol that uses a TDMA protocol similar to the one used in PRKS and that uses the physical interference model to derive interference relations between nodes but ignores cumulative interference in networks;
%\item \emph{CMAC}: a contention-based MAC protocol where a node transmits at a time instant only if the SINR of this transmission and the SINRs of other concurrent transmissions overheard by the node are above a certain threshold;
%\item \emph{SCREAM}: a TDMA scheduling protocol using the SCREAM primitive to schedule concurrent transmissions according to the physical interference model;
%\item \emph{PRKS-R}: same as PRKS but formulates the PRK model instantiation problem as a deadbeat PID regulation control problem instead of as a minimum-variance regulation control problem;
%\item \emph{PRKS-L}: same as PRKS but directly use the linear model instead of its refined model.
%\end{itemize}
%Among these protocols, RTS-CTS and the default CSMA represent the protocol-model-based techniques in existing industry standards such as IEEE 802.15.4 and 802.11p; RIDB, CMAC, and SCREAM represent the techniques used in existing physical-model-based scheduling. 
Through measurement study in sensor network testbed NetEye and Indriya, we observe that PRKS enables predictably high link reliability (e.g., 95\%) in different network and environmental conditions without a priori knowledge of these conditions, and, through local distributed coordination, PRKS achieves a channel spatial reuse very close to what is enabled by the state-of-the-art centralized scheduler while ensuring the required link reliability, and improves substantially over all other protocols in terms of reliability, delay, and throughput.
The source code is publicly available at \url{https://github.com/xhliu/prks}.
}


\subsection{Multi-Timescale Adaptation (MTA) Routing Protocol}
\cvitem{}{
MTA identifies minimal energy paths that can meet probabilistic deadlines of real-time traffic, given the notorious dynamics and uncertainties of path delays in wireless networks. \textbf{TinyOS is not designed with real-time support in mind, so it's not surprising to find many of its features detrimental to real-time routing, such as task and split-phase APIs, to name a few. Many core APIs are altered in a systematic way to enable real-time networking without devising an entirely new real-time OS.} More precisely, the following obstacles appear in realizing it on resource-scarce TelosB motes running TinyOS: (1) the standard TinyOS task queue is served in FIFO order so urgent tasks can be postponed by less urgent ones, causing deadline misses that can otherwise be avoided; (2) the default CC2420 radio stack is non-blocking and synchronous, making critical codes like packet transmission and reception susceptible to excessive delay; (3) tracking relative deadlines of traffic necessitates time synchronization across a link while there are bugs in the default packet-level time synchronization for TelosB, especially under heavy load; (4) the number of paths in a directed-acyclic-graph (DAG) maintained by MTA increases exponentially with the network diameter, making it impossible to store all of them in memory to choose the optimal path from. \textbf{Despite the aforementioned obstacles, I managed to implement the whole protocol independently. Besides MTA itself, I also implemented 4 other protocols and 7 MTA variants from scratch.} %:}
%\begin{itemize}
%\item \emph{MCMP}: a multi-path QoS routing protocol where end-to-end QoS requirements on reliability and timeliness are uniformly divided into per-hop reliability and timeliness requirements, upon which a node chooses the minimum number of next-hops to satisfy the per-hop requirements in data delivery; 
%\item \emph{MMSPEED}: the geographic routing protocol MMSPEED that routes and schedules packet transmissions based on nodes' distances to destinations, packet delivery deadlines, and mean link delays; MMSPEED also tries to improve packet delivery reliability by transmitting packets along multiple paths;
%\item \emph{MMSPEED-CD}: same as MMSPEED but, instead of using the mean link delay, uses a conservative estimate of link delay that equals the sum of the mean delay and three times the standard deviation of the delay; 
%\item \emph{SDRCS}: similar to MMSPEED but, instead of using geographic distance, uses data-forwarding hop-count as the measure of distance, where the hop-count is computed based on received-signal-strength (RSS) between nodes; data forwarding is through receiver contention similar to that in opportunistic routing;
%\item \emph{M-DS}: same as MTA but directly estimate path delay quantiles using non-parametric method $P^2$ and path delay samples that are collected in a distributed manner;
%\item \emph{M-DB}: same as MTA but estimates the mean and variance of path delay directly through path delay samples; \item \emph{M-ST}: same as MTA but estimates the mean and variance of path delay as the sum of the mean and variance of the sojourn time  at each node of the path, without decomposing the sojourn time into the individual packet-times;
%\item \emph{M-MD}: Same as MTA but maintains the data forwarding DAG based on mean link/path delay instead of link/path ETX;
%\item \emph{M-mDQ}: same as MTA but forwards packets to the next-hop candidate with the minimum path delay quantile instead of the one with minimum path ETX;
%\item \emph{mDQ}: same as M-mDQ but does not use the data forwarding DAG of MTA for stability control;
%\item \emph{M-FCFS}: same as MTA but uses FCFS instead of EDF for intra-node transmission scheduling.
%\end{itemize}
Two testbeds of 127+ motes have verified MTA's significant advantages over the state of the art for a variety of settings.
The source code is publicly available at \url{https://github.com/xhliu/mta}.
}

%both the default CC2420 and CC2420X radio stack
%                % arguments 3 to 6 are optional
%%\cventry{year--year}{Job title}{Employer}{City}{}{Description}                % arguments 3 to 6 are optional
%\subsection{Proficiencies}
%\cventry{10 years}{Perl}{}{}{}{
%I usually prefer Perl for non-graphical implementations.
%The word prediction simulations for my dissertation are written in Perl, as well as much of the dissertation support code.
%I also have experience writing web applications with Perl/CGI and DBI.
%}
%\cventry{12 years}{Java}{}{}{}{
%I prefer Java for applications with graphical interfaces, such as user evaluation of word prediction.
%I also tend to use Java for XML processing, such as analysis of log files from dissertation simulations.
%Also, I used Java and the JADE library to implement the vehicle-to-grid coalition server and client.
%}
%\cventry{10 years}{C++}{}{}{}{I use C++ mainly for academic purposes --- teaching second-semester programming/design and third-semester data structures as well as certain graduate classes (graphics).}
%
%\cventry{familiarity}{Javascript, Python, Lua}{}{}{}{I've written small proof-of-concept applications in several other languages. Many of my systems involving web data display use Javascript to accomplish small tasks.
%}
